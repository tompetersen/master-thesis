\section{Einbindung in OSSIM}

\label{sec_impl_integration_into_ossim}

%- Vorgehen
%
%- Nur für Syslog, keine anderen Fomate betrachtet
%
%- Syslog-Nachrichten werden entgegengenommen, geparst und Config-basiert einzelne Datenfelder bearbeitet (basierend auf RegEx)
%
%- Konfigurationsdateien für Datenquellen (leichte Erweiterbarkeit, auch im Bezug auf neue Datenquellen, ...) mit Beispiel
%
%- Plugins (leichte Erweiterbarkeit, ...)

\todo{OSSIM-Aufbau erst hier einführen, vorher allgemein halten - NEIN, Aufbau bereits in state -> darauf Bezug nehmen }


OSSIM erlaubt eine verteilte Installation am Empfang von Logdaten beteiligter Komponenten.
Dadurch wird der Datenfluss in OSSIM gegenüber dem in Abschnitt \ref{TODO} vorgestellten allgemeinen Datenfluss in SIEM-Systemen noch um eine zusätzliche Komponente ergänzt: den sogenannten Sensor. Eine Installation kann aus einem zentralen Server und mehreren Sensoren bestehen. Die Sensoren übernehmen das Empfangen und Parsen von Logdaten und senden diese im OSSIM-eigenen Eventformat (siehe Abschnitt \ref{TODO)) an den Server. Hierdurch kann die beim Parsen und Speichern von Events entstehende Rechenlast besser verteilt werden. Eine Übersicht über den entstehenden Datenfluss bietet Abbildung \ref{fig:ossim_data_access_point}. \todo{Bezug zu state_siem herstellen}

\begin{figure}[]
    \centering
        \includegraphics[width=0.9\textwidth]{dia/ossim_data_access_point.pdf}
    \caption{Mögliche Eingriffspunkte in den OSSIM-Datenfluss.}
    \label{fig:ossim_data_access_point}
\end{figure}

Hierdurch entstehen gegenüber den in Abschnitt \ref{TODO} beschriebenen Möglichkeiten zum Eingriff in den Datenfluss zwei weitere Möglichkeiten zum Eingriff:

\begin{enumerate}
 \setcounter{enumi}{3}

\item \textbf{Patchen des OSSIM-Sensor-Agents}\\
  Bei dieser Lösung müsste der OSSIM-Agent des Sensors so verändert werden, dass vor dem Senden der Events an den Server die Pseudonymisierung stattfindet. Daten erreichen den OSSIM-Server nur pseudonymisiert und mehrfaches Parsen wie in der zweiten Lösung wird verhindert. Auf der anderen Seite erfordert diese Lösung einen Eingriff in die Funktionsweise von OSSIM, was beispielsweise bei Updates von OSSIM zu Problemen führen kann. Außerdem liegen die Daten zu Beginn in nicht-pseudonymisierter Form im Sensor vor. \todo{Syslog-Problematik erwähnen} Zusätzlich erfordert diese Lösung die verteilte Installation von OSSIM-Sensor und -Server, schließt also die All-In-One-Installation aus.
  
\item \textbf{Sensor-Server-Proxy}\\
  Hier wird ein Proxy zwischen Sensor und Server geschaltet, der bereits geparste Events pseudonymisiert und anschließend an den Server sendet. Dieser Ansatz würde mehrfaches Parsen verhindern und dafür sorgen, dass nur pseudonymisierte Logdaten den OSSIM-Server erreichen. Wie die vorhergehende Lösung würde er jedoch nur in der verteilten Installation funktionieren und zusätzlich in die Kommunikation zwischen Sensor und Server aktiv eingreifen, was im Hinblick auf die Nachrichtenintegrität\footnote{
    In der aktuellen Version von OSSIM werden Nachrichten unverschlüsselt und nicht signiert zwischen Sensor und Server versendet, aber zu hoffen ist, dass dieser Zustand sich in zukünftigen Versionen noch ändert.
  } und auch auf geändertes Verhalten nach Updates von OSSIM einen Nachteil darstellt.
  
\end{enumerate}

Deshalb wurde sich für den zu entwickelnden Prototypen dazu entschieden, \todo{...}






Für die in dieser Arbeit zu leistende prototypische Umsetzung des Systems wurde sich auf den am häufigsten\footnote{
  Die in OSSIM bereits mitgelieferten Plugins bestätigen dies. Unter den Hunderten Plugins ist nur ein einziges, das einen anderen Mechanismus als das Syslog-Protokoll nutzt. Auch wenn beispielsweise Plugins, die eine Datenbankabfrage enthalten, immer dem Anwendungsfall angepasst und daher nicht in OSSIM inkludiert werden können, so unterstützt dies doch die Annahme des Syslog-Protokolls als am häufigsten genutzten Weg und damit als geeignet für den Fokus dieser Arbeit.
} genutzten Weg des Datenerhalts in OSSIM (siehe Abschnitt \ref{subsec_state_siem_parsing}) beschränkt: das Entgegennehmen der Daten über das Syslog-Protokoll. 




Die Behandlung von verschiedenen Datenquellen wird durch Konfigurationsdateien ermöglicht:

\begin{lstlisting}[morekeywords={general,active,pattern,group1,group2}]
[general]
active=True

[group1]
pattern=^(?P<time>\w+ *\d{1,2} \d{2}:\d{2}:\d{2}) (?P<device>[^:]+): Testing my device USER=(?P<user>.+)$
time=Substitute(substitute = 'somevalue_time')
device=Substitute(substitute = 'somevalue_device')
user=Pseudonymize()

[group2]
pattern=^(?P<test>.*)$
test=Pseudonymize()
\end{lstlisting}

Eine Konfigurationsdatei kann aus mehreren Bereichen bestehen. Der \texttt{general}-Bereich enthält allgemeine Angaben über das Plugin. Um unterschiedliche Lognachrichten eines Gerätes bündeln zu können, kann eine Konfigurationsdatei weiterhin mehrere Bereiche enthalten, die jeweils die Verarbeitung einer bestimmten Lognachricht beschreiben. Angegeben werden muss jeweils ein regulärer Audruck, der die Nachricht beschreibt und mehrere Gruppen (\texttt{(?P<name>...)}) enthalten kann. Für jede dieser Gruppen muss eine Angabe zu dem Plugin inklusive notwendiger Parameter gemacht werden, dass die Gruppe verarbeiten soll. Durch diese Konfigurationsdateien können Nachrichten unbekannter Formate aus neuen Datenquellen leicht in das bestehende System eingebunden werden.



Die Erweiterbarkeit um neue Datenschutztechniken wird durch leicht erweiterbare Plugins ermöglicht. Ein Plugin muss lediglich die Methode \texttt{handle\_data} implementieren, die die originalen Daten und alle in der Konfiguration angegebenen Parameter erhält. Ein einfaches Plugin, das die Daten durch ein in der Konfiguration angegebenen Wert ersetzt, könnte so aussehen:

\begin{lstlisting}[language=Python]
class Substitute(AbstractPlugin):

    def handle_data(self, data: str, **kwargs) -> str:
        if 'substitute' in kwargs:
            return kwargs['substitute']
        else:
            raise MissingSubstituteError
\end{lstlisting}