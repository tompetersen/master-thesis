\section{Schwellwertschemata}

\label{sec_basics_threshold}

%- Shamir How to share a secret?
%- Public Key Problematik
%- Was ist das? (siehe auch Paper für Definition)
%- Fünde (RSA, Paillier, ...) und Desmedt/Frankel evtl. hier schon Pedersen/...

Mit der Verbreitung technischer Systeme, die kryptographische Verfahren nutzen, musste auch das Problem der sicheren Aufbewahrung und Verteilung kryptographischer Schlüssel betrachtet werden. Die Sicherheit dieser Schlüssel ist essentiell für den Betrieb solcher Systemen. Das einfache Speichern eines Schlüssels an einem Ort besitzt eine hohe Verlustwahrscheinlichkeit, da ein einzelner Fehler wie unbeabsichtigtes Löschen oder Speichermedienausfall den Schlüssel unwiederbringlich zerstören kann. Das mehrfache Speichern eines Schlüssels an verschiedenen Orten erhöht hingegen die Gefahr eines Schlüsseldiebstahls oder -missbrauchs, da auch die Angriffsoberfläche vergrößert wird. Bei möglichen Lösungen dieses Problems müssen also immer die Integrität und die Vertraulichkeit eines Schlüssels gegeneinander abgewogen werden. \cite{gemmell1997}

Ausgehend von diesen Überlegungen entwickelte Shamir das erste \((k,n)\)-Schwellwert-Schema\footnote{
  Im selben Jahr veröffentlichte auch Blakley eine Lösung dieses Problems, die auf den Schnittpunkten von Hyperebenen über endlichen Feldern beruht \cite{blakley1979}.
}: Ein Geheimnis \(D\) wird so in \(n\) Teile \(D_1, \dots, D_n\) zerlegt, dass durch Kenntnis von mindestens \(k\) Teilen das Geheimnis wieder aufgedeckt werden kann, aber jede Kombination aus höchstens \(k-1\) Teilen keine Informationen über \(D\) liefert. Shamirs Lösung bediente sich der Polynominterpolation auf der Basis modularer Arithmetik \cite{shamir1979}:

Die Menge aller Ganzzahlen modulo einer Primzahl \(p\) bilden einen Körper, in welchem Polynominterpolation möglich ist. Soll nun das Geheimnis \(D\) (das o.B.d.A. als Ganzzahl angenommen wird) aufgeteilt werden, so wird eine Primzahl \(p\) mit \(p > D\) und \(p > n\) gewählt. Weiterhin wird ein Polynom 
\[q(x) = a_0 + a_1x + \dots + a_{k-1}x^{k-1} \text{ mit } a_0 = D\] 
derart gewählt, dass \(a_1, \dots, a_{k-1}\) gleichverteilt aus der Menge \(\{0,\dots,p\}\) stammen. Die einzelnen Teile des Geheimnisses werden nun als
\[D_1=q(1), \dots, D_i=q(i), \dots, D_n=q(n)\]
jeweils modulo \(p\) berechnet.

Um nun aus diesen einzelnen Teilen wieder das ursprüngliche Geheimnis zu erhalten, wird das Verfahren der Polynominterpolation verwendet. 
\todo{Erweiterte Beschreibung}



Auf Basis dieses Verfahrens kann also die Integrität eines Schlüssels erhöht werden, da nun selbst bei Verlust von \(n-k\) Teilen der Schlüssel noch wiederhergestellt werden kann. Auf der anderen Seite ist die Vertraulichkeit jedoch höher als bei der mehrfachen Speicherung des Schlüssels im Original, da mindestens \(k\) Teile des Schlüssels zur Wiederherstellung vorliegen müssen.

Das Problem dieser Lösungen bezogen auf den in dieser Arbeit behandelten Anwendungsfall ist jedoch, dass das Geheimnis nach erstmaligem Aufdecken bekannt ist. Wünschenswert wäre ein Verfahren, bei dem nur ein entsprechend verschlüsseltes Datum (bspw. der gesuchte Eintrag in einer Pseudonym-Tabelle) aufgedeckt werden kann, ohne dass der kombinierte Schlüssel selbst bekannt wird. 

%- 87 SocietyOriented \cite{desmedt1987}
%- 93 Threshold decryption (non-interactive) \cite{desmedt1993}
%- Def. nach 96 Boneh \cite{boneh2006}


In \cite{desmedt1987} wird dieses Problem das erste Mal im Kontext von verschlüsselten Nachrichten an Gruppen betrachtet: Ein Sender möchte eine Nachricht an eine Gruppe von Empfängern senden, die nur in Zusammenarbeit die Nachricht entschlüsseln können sollen. Hier wird auch die zentrale Forderung aufgestellt, den mehrfachen Nachrichtenaustausch zwischen Sender und Empfänger(n) bei der Entschlüsselung (sogenannte Ping-Pong-Protokolle) zu vermeiden. \\
In \cite{desmedt1993} spricht der Autor bei dieser Klasse von Verfahren von \textit{threshold decryption} und fordert weiterhin, dass praktisch einsatzbare Systeme auch \textit{non-interactive} sein sollten, also bei der Entschlüsselung keinen aufwendigen Datenaustausch zwischen den Teilnehmern notwendig machen.

In \cite{boneh2006} werden diese Systeme formalisiert. Ein \textit{Threshold-Public-Key-Encryption}-System besteht aus fünf Schritten: \todo{EZ zu Schritt 3: \(u_i = (i, ...)\) ???}
\begin{enumerate}
	\item \(Setup(n,k,\Lambda)\) liefert ein Tripel \((PK, VK, SK)\), bestehend aus dem öffentlichen Schlüssel \(PK\), einem Verifikationsschlüssel \(VK\) und einer \(n\)-elementigen Liste aus \textit{Private Key Shares}, von denen jeder Teilnehmer einen \textit{Share} erhält. \(\Lambda\) wird als initialer Sicherheitsparameter bezeichnet.
	\item \(Encrypt(PK, M)\) liefert die verschlüsselte Nachricht \(C\).
	\item \(ShareDecrypt(PK, i, SK_i, C)\) liefert ein \textit{Decryption Share} \(\mu=(i, \mu^i)\) des \(i\)-ten Teilnehmers, das im 5. Schritt zusammen mit weiteren \textit{Shares} zur Entschlüsselung der Nachricht genutzt wird. 
	\item \(ShareVerify(PK, VK, C, \mu)\) überprüft ein \textit{Decryption Share} auf Validität.
	\item \(Combine(PK, VK, C, {\mu_1, \dots,\mu_k, \dots})\) verknüpft die \textit{Decryption Shares} von mindestens \(k\) Teilnehmern und liefert die Nachricht \(M\) zurück.
\end{enumerate}
Anforderungen an diese Schritte sind \cite{boneh2006} zu entnehmen. \todo{Hier ergänzen.}

