\section{Schwellwertschemata}

\begin{itemize}
  \item \textbf{Grundlagen} Von Shamirs Secret Sharing bis heute
  \item \textbf{Konkretes Verfahren} Im Detail erläutern - vmtl. Desmedt auf Basis von ElGamal
  \item Zusätzlich Erweiterungen dieses Verfahrens wie verteilte Schlüsselgenerierung.
\end{itemize}

%- Desmedt, Frankel: ElGamal \cite{DesmedtFrankel1990}
%- setzt zentralen "Dealer" voraus
%- Pedersen und verbesserte Variante 
%- Andere Möglichkeiten: Paillier, RSA, ...

\label{sec_state_threshold}

\subsection{Schemata}

\todo{Erweitern um weitere Systeme}

Ein solches System, das auf dem ElGamal-Algorithmus und damit dem Diskreten-Logarithmus-Problem basiert, veröffentlichten die Autoren in \cite{DesmedtFrankel1990}. \todo{Details} Dieser Ansatz setzt in der \textit{Setup}-Phase auf eine zentrale vertrauenswürdige Stelle zur Erzeugung der Schlüssel und \textit{Shares}. In \cite{pedersen1991} stellt der Autor basierend auf diesen Ergebnissen ein Verfahren vor, das bei der Schlüsselgenerierung ohne eine vertrauenswürdige Instanz auskommt. Dieses Verfahren wird in \cite{gennaro1999} noch einmal verbessert.\\
Basierend auf dem jetzigen Recherchestand würde sich diese Kombination von Verfahren gut für den angestrebten Anwendungszweck eignen. Konkrete offene Implementierungen wurden jedoch bisher nicht gefunden, so dass möglicherweise eine eigene Implementierung umgesetzt werden muss.

Neben diesem Verfahren gibt es noch weitere Ansätze basierend auf RSA \cite{desmedt1993, nguyen2005} oder dem Paillier-Kryptosystem \cite{paillier1999, damgard2001}, die jedoch deutlich komplexer zu sein scheinen. 

\subsection{Desmedt und Frankel: Threshold cryptosystems}

Das ursprüngliche Verfahren setzt eine vertrauenswürdige, zentrale Instanz zur Schlüsselgenerierung voraus. Das Verfahren lässt sich in 4 Phasen unterteilen: Generierung von Schlüssel und Shares, Verschlüsselung einer Nachricht, Generierung der partiellen Entschlüsselungen mithilfe der Shares, Kombination der partiellen Entschlüsselungen zur ursprünglichen Nachricht. \todo{? Beziehen auf basics}

% Setup: Generierung von Schlüssel und Shares

Die zentrale Instanz erstellt ein Schlüsselpaar analog zu dem Vorgehen im ElGamal-Verfahren. Für eine \todo{Ergänzen oder ElGamal in Basics aufnehmen - siehe auch Handbook of applied cryptography}

Der private Schlüssel \(a\) wird dann mittels Shamir's Secret Sharing (siehe Abschnitt \ref{sec_basics_threshold_shamir}) in \(n\) Shares \(x_i, y_i\) für \(i \in {1, \dots, n}\) zerlegt, die dann an die entsprechenden Besitzer verteilt werden. Nachfolgend wird die zentrale Instanz nicht mehr benötigt und kann alle verbliebenen Werte im Speicher löschen.

% Verschlüsselung

Die Verschlüsselung einer Nachricht \(m\) funktioniert analog zum ursprünglichen ElGamal-Verfahren. Es wird ein zufälliger Wert \(r < q\) mit \(ggT(r,q) = 1\) generiert. Der Schlüsseltext ergibt sich als \((g^k, M * g^{a*r})\), wobei \(g^a\) den bereits generierten öffentlichen Schlüssel darstellt.

% Generierung der partiellen Entschlüsselungen

Die partiellen Verschlüsselungen 

\subsection{Dezentrale Schlüsselgenerierung}



\subsection{TEMP}

\todo{Some things should be moved to implementation.}

\textbf{(Zentrale) Schlüsselgenerierung }

% https://crypto.stackexchange.com/questions/1451/elgamal-multiplicative-cyclic-group-and-key-generation
% Introduction to modern cryptography 8.3.3 (pdf 343ff)
% Sharing of parameters: Introduction to modern cryptography ElGamal implementation issues (pdf 425)
Hier werden sichere Primzahlen bzw. Sophie-Germain-Primzahl verwendet: Zwei Primzahlen \(p\) und \(q\) mit der Eigenschaft \(p = 2q + 1\). Ein Algorithmus zu ihrer Erzeugung kann im Handbook of applied cryptography gefunden werden. \todo{cite} Im Wesentlichen wird solange eine Primzahl \(q\) im gewünschten Bereich zufällig gewählt, bis \(2q + 1\) ebenfalls eine Primzahl ist.

Weiterhin wird ein Generator der Untergruppe der Ordnung \(q\) von \(\mathbb{Z}_p^*\) berechnet. Hierzu wird lediglich solange ein zufälliges Element \(g\) aus \(\mathbb{Z}_p^*\) gewählt bis 

\[g^q \equiv 1 \mod p \text{ und } g^2 \not\equiv 1 \mod p\] 

gelten. Da Untergruppen von \(\mathbb{Z}_p^*\) nach dem Satz von Lagrange lediglich die Ordnungen \(1,2,q \text{ oder } 2q\) besitzen, werden durch obenstehende Bedingungen lediglich Untergruppen der Ordnung \(q\) zugelassen.

Der (temporär erstellte) geheime Schlüssel \(a \in \mathbb{Z}_q\) wird zufällig gewählt. Hieraus wird der öffentliche Schlüssel \(pk = g^a \mod p\) berechnet.

Der geheime Schlüssel wird anschließend analog zu Shamirs Secret Sharing (unter Nutzung von \(\mathbb{Z}_q\)) in einzelne Shares \((x_i, y_i) = (x_i, q(x_i))\) aufgeteilt und diese werden an die Teilnehmer verteilt. \todo{ref shamir}

\textbf{Verschlüsselung}

Anschließend kann eine Nachricht mithilfe von \(pk\) analog zu dem ElGamal-Verfahren verschlüsselt werden. \todo{ref ElGamal} So erhält man \((v,c) = (g^k, m \cdot g^{ak})\) für ein zufällig gewähltes \(k \in \mathbb{Z}_q\).

\textbf{Partielle Entschlüsselung}

Jeder Besitzer eines Shares \((x_i, y_i)\) berechnet für den zu entschlüsselnden Schlüsseltext \((v,c)\) seine partielle Entschlüsselung \((x_i, v^{y_i})\) und sendet dieses an eine zentrale Instanz, den Combiner. Empfängt dieser mindestens \(t\) partielle Entschlüsselungen\footnote{
  Zur Erinnerung: \(t\) beschreibt die Mindestzahl zur Entschlüsselung benötigter Shares des Schwellwertschemas.
}, so kann er den Klartext wiederherstellen.

\textbf{Entschlüsselung}

\todo{threshold gruppe erwähnen - es handelt sich im Zweifel nicht um die gleichen xi,yi}
Hierzu berechnet der Kombiner die Lagrange-Koeffizienten \(\lambda_i \in \mathbb{Z}_q\) wie in Shamir's Secret Sharing beschrieben. Anschließend kann
 
\[g^{ak} = \prod_{i=1}^k (v^{y_i})^{\lambda_i}\]

berechnet werden. Dies funktioniert, da 

\[
\prod_{i=1}^k (v^{y_i})^{\lambda_i} = 
\prod_{i=1}^k (g^k)^{y_i \cdot \lambda_i} = 
(g^k)^{\sum_{i=1}^{k} y_i \cdot \lambda_i} \overset{(*)}{=}
(g^k)^a
\]

gilt. Der letzte Schritt \((*)\) folgt direkt aus dem zugrundeliegenden Secret Sharing und ist in dieser Form bereits in Abschnitt \ref{sec_basics_threshold_shamir} zu finden.

Anschließend kann die Nachricht als \(m = c \cdot (g^{ak})^{(-1)}\) wiederhergestellt werden. 
